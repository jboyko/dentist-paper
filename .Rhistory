comp
p
anc
k.rates
print(Q)
rowSums(Q)
p
rate
corhmm.obj$solution[!is.na(corhmm.obj$solution)]
?ancRECON
#Now lets calculate some marginals!
p <- sapply(1:max(corhmm.obj$index.mat, na.rm = TRUE), function(x) na.omit(c(corhmm.obj$solution))[na.omit(c(corhmm.obj$index.mat) == x)][1])
all_recon
all_recon <- mclapply(all_trees, function(x) GetEdgeMarginal(p=p, phy=x, data=new.data, rate.mat=corhmm.obj$index.mat, rate.cat=corhmm.obj$rate.cat, ntraits=ntraits, root.p=corhmm.obj$root.p, model = "ARD", collapse = collapse), mc.cores = ncores)
# the main function for doing a marginal time slice reconstruction
ancRECON_slice <- function(corhmm.obj, time_slice, collapse=TRUE, ncores = 1){
if(max(time_slice) >= max(branching.times(corhmm.obj$phy))){
stop("time_slice must be less than the maximum branching time of the tree")
}
# get the fake node locations for the reconstruction based on the time slice
to_recon <- sapply(time_slice, function(x) getNodePlacementsForSlice(phy, x))
to_recon <- (apply(to_recon, 2, function(x) do.call(cbind, x)))
for(i in seq_len(length(time_slice))){
to_recon[[i]] <- cbind(time_slice = time_slice[i], to_recon[[i]])
}
to_recon <- do.call(rbind, to_recon)
# create a dummy tip and dummy data
tip.name <- "FakeyMcFakerson"
tip <- list(edge=matrix(c(2,1),1,2), tip.label=tip.name, edge.length=0, Nnode=1)
class(tip) <- "phylo"
new.data <- corhmm.obj$data.legend
new.data[,1] <- as.character(new.data[,1])
new.data <- rbind(new.data, "?")
new.data[nrow(new.data), 1] <- "FakeyMcFakerson"
ntraits <- max(as.numeric(corhmm.obj$data.legend$d))
# get all the new phys
print(paste0("Reconstructing ", nrow(to_recon), " nodes for ", length(time_slice), " time slices..."))
all_trees <- apply(to_recon, 1, function(x) bind.tree(corhmm.obj$phy, tip, x[2], x[3]))
#Now lets calculate some marginals!
p <- sapply(1:max(corhmm.obj$index.mat, na.rm = TRUE), function(x) na.omit(c(corhmm.obj$solution))[na.omit(c(corhmm.obj$index.mat) == x)][1])
all_recon <- lapply(all_trees, function(x) GetEdgeMarginal(p=p, phy=x, data=new.data, rate.mat=corhmm.obj$index.mat, rate.cat=corhmm.obj$rate.cat, ntraits=ntraits, root.p=corhmm.obj$root.p, model = "ARD", collapse = collapse))
all_recon <-  do.call(rbind, all_recon)
colnames(all_recon) <- colnames(corhmm.obj$solution)
out <- cbind(to_recon, all_recon)
return(out)
}
plot_slice_recon <- function(phy, slice_df, col=NULL){
plot(phy, show.tip.label = FALSE)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
node <- (lastPP$Ntip + 1):length(lastPP$xx)
XX <- lastPP$xx[node]
YY <- lastPP$yy[node]
for(i in 1:nrow(slice_df)){
focal <- slice_df[i,]
xx <- lastPP$xx[focal[2]] - focal[3]
yy <- lastPP$yy[focal[2]]
pp <- focal[-c(1:3)]
floating.pie.asp(xx, yy, pp, radius = 0.5, col = col)
}
}
# testing
library(corHMM)
library(parallel)
library(viridis)
test <- ancRECON_slice(corhmm.obj, time_slice = c(10, 20, 30, 40), collapse = TRUE, ncores = 4)
p
print(Q)
test <- ancRECON_slice(corhmm.obj, time_slice = c(10, 20, 30, 40), collapse = TRUE, ncores = 4)
v
fixer
v * fixer
fixer
corhmm.obj$phy$node.label <- NULL
# the main function for doing a marginal time slice reconstruction
ancRECON_slice <- function(corhmm.obj, time_slice, collapse=TRUE, ncores = 1){
if(max(time_slice) >= max(branching.times(corhmm.obj$phy))){
stop("time_slice must be less than the maximum branching time of the tree")
}
# get the fake node locations for the reconstruction based on the time slice
to_recon <- sapply(time_slice, function(x) getNodePlacementsForSlice(phy, x))
to_recon <- (apply(to_recon, 2, function(x) do.call(cbind, x)))
for(i in seq_len(length(time_slice))){
to_recon[[i]] <- cbind(time_slice = time_slice[i], to_recon[[i]])
}
to_recon <- do.call(rbind, to_recon)
# create a dummy tip and dummy data
tip.name <- "FakeyMcFakerson"
tip <- list(edge=matrix(c(2,1),1,2), tip.label=tip.name, edge.length=0, Nnode=1)
class(tip) <- "phylo"
new.data <- corhmm.obj$data.legend
new.data[,1] <- as.character(new.data[,1])
new.data <- rbind(new.data, "?")
new.data[nrow(new.data), 1] <- "FakeyMcFakerson"
ntraits <- max(as.numeric(corhmm.obj$data.legend$d))
# get all the new phys
print(paste0("Reconstructing ", nrow(to_recon), " nodes for ", length(time_slice), " time slices..."))
corhmm.obj$phy$node.label <- NULL
all_trees <- apply(to_recon, 1, function(x) bind.tree(corhmm.obj$phy, tip, x[2], x[3]))
#Now lets calculate some marginals!
p <- sapply(1:max(corhmm.obj$index.mat, na.rm = TRUE), function(x) na.omit(c(corhmm.obj$solution))[na.omit(c(corhmm.obj$index.mat) == x)][1])
all_recon <- lapply(all_trees, function(x) GetEdgeMarginal(p=p, phy=x, data=new.data, rate.mat=corhmm.obj$index.mat, rate.cat=corhmm.obj$rate.cat, ntraits=ntraits, root.p=corhmm.obj$root.p, model = "ARD", collapse = collapse))
all_recon <-  do.call(rbind, all_recon)
colnames(all_recon) <- colnames(corhmm.obj$solution)
out <- cbind(to_recon, all_recon)
return(out)
}
test <- ancRECON_slice(corhmm.obj, time_slice = c(10, 20, 30, 40), collapse = TRUE, ncores = 4)
undebug(corHMM:::dev.corhmm)
#Marginal reconstruction function for our custom corHMM
GetEdgeMarginal <- function(p, phy, data, rate.mat, rate.cat, ntraits, model, root.p, collapse = TRUE){
nb.tip <- length(phy$tip.label)
nb.node <- phy$Nnode
data.for.likelihood.function <- corHMM:::rate.cat.set.corHMM.JDB(phy=phy, data=data, rate.cat=rate.cat, ntraits = ntraits, model = model, collapse = collapse)
if(!is.null(rate.mat)){
rate <- rate.mat
data.for.likelihood.function$np <- max(rate, na.rm=TRUE)
rate[is.na(rate)]=max(rate, na.rm=TRUE)+1
data.for.likelihood.function$rate <- rate
data.for.likelihood.function$index.matrix <- rate.mat
## for precursor type models ##
col.sums <- which(colSums(rate.mat, na.rm=TRUE) == 0)
row.sums <- which(rowSums(rate.mat, na.rm=TRUE) == 0)
drop.states <- col.sums[which(col.sums == row.sums)]
if(length(drop.states > 0)){
data.for.likelihood.function$liks[,drop.states] <- 0
}
###############################
}else{
drop.states <- NULL
}
phy <- reorder(phy, "pruningwise")
nodes <- unique(phy$edge[,1])
taxon.index <- grep("FakeyMcFakerson", x=phy$tip.label)
marginal.probs.tmp <- numeric(dim(data.for.likelihood.function$Q)[2])
nstates = which(!data.for.likelihood.function$liks[taxon.index,] == 0)
states.keep = data.for.likelihood.function$liks[taxon.index,]
for(state.index in setdiff(1:dim(data.for.likelihood.function$Q)[2], drop.states)){
data.for.likelihood.function$liks[taxon.index,] = 0
data.for.likelihood.function$liks[taxon.index,state.index] = 1
# print(data.for.likelihood.function$liks)
marginal.probs.tmp[state.index] <- -corHMM:::dev.corhmm(p=log(p), phy=phy, liks=data.for.likelihood.function$liks, Q=data.for.likelihood.function$Q, rate=data.for.likelihood.function$rate, root.p=root.p, rate.cat = rate.cat, order.test = FALSE, lewis.asc.bias = FALSE)
}
data.for.likelihood.function$liks[taxon.index,] <- states.keep
best.probs <- max(marginal.probs.tmp[nstates])
marginal.probs.rescaled <- marginal.probs.tmp[nstates] - best.probs
marginal.probs.final <- exp(marginal.probs.rescaled) / sum(exp(marginal.probs.rescaled))
return(marginal.probs.final)
}
# creates a table for locating where to add nodes. first column is the node index (tip or internal). second column is the time period from the node to add
getNodePlacementsForSlice <- function(phy, time_slice){
to_add <- data.frame(node = 1:length(phy$tip.label), position = time_slice)
nodes_younger_than_slice <- branching.times(phy)[branching.times(phy) < time_slice]
node_to_add <- data.frame(node = as.numeric(names(nodes_younger_than_slice)), position = time_slice - nodes_younger_than_slice)
to_add <- rbind(to_add, node_to_add)
edge_lengths <- phy$edge.length[match(to_add[,1], phy$edge[,2])]
to_add <- to_add[edge_lengths - to_add[,2] > 0,] # exludes nodes too far away
return(to_add)
}
# the main function for doing a marginal time slice reconstruction
ancRECON_slice <- function(corhmm.obj, time_slice, collapse=TRUE, ncores = 1){
if(max(time_slice) >= max(branching.times(corhmm.obj$phy))){
stop("time_slice must be less than the maximum branching time of the tree")
}
# get the fake node locations for the reconstruction based on the time slice
to_recon <- sapply(time_slice, function(x) getNodePlacementsForSlice(phy, x))
to_recon <- (apply(to_recon, 2, function(x) do.call(cbind, x)))
for(i in seq_len(length(time_slice))){
to_recon[[i]] <- cbind(time_slice = time_slice[i], to_recon[[i]])
}
to_recon <- do.call(rbind, to_recon)
# create a dummy tip and dummy data
tip.name <- "FakeyMcFakerson"
tip <- list(edge=matrix(c(2,1),1,2), tip.label=tip.name, edge.length=0, Nnode=1)
class(tip) <- "phylo"
new.data <- corhmm.obj$data.legend
new.data[,1] <- as.character(new.data[,1])
new.data <- rbind(new.data, "?")
new.data[nrow(new.data), 1] <- "FakeyMcFakerson"
ntraits <- max(as.numeric(corhmm.obj$data.legend$d))
# get all the new phys
print(paste0("Reconstructing ", nrow(to_recon), " nodes for ", length(time_slice), " time slices..."))
corhmm.obj$phy$node.label <- NULL
all_trees <- apply(to_recon, 1, function(x) bind.tree(corhmm.obj$phy, tip, x[2], x[3]))
#Now lets calculate some marginals!
p <- sapply(1:max(corhmm.obj$index.mat, na.rm = TRUE), function(x) na.omit(c(corhmm.obj$solution))[na.omit(c(corhmm.obj$index.mat) == x)][1])
all_recon <- lapply(all_trees, function(x) GetEdgeMarginal(p=p, phy=x, data=new.data, rate.mat=corhmm.obj$index.mat, rate.cat=corhmm.obj$rate.cat, ntraits=ntraits, root.p=corhmm.obj$root.p, model = "ARD", collapse = collapse))
all_recon <-  do.call(rbind, all_recon)
colnames(all_recon) <- colnames(corhmm.obj$solution)
out <- cbind(to_recon, all_recon)
return(out)
}
plot_slice_recon <- function(phy, slice_df, col=NULL){
plot(phy, show.tip.label = FALSE)
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
node <- (lastPP$Ntip + 1):length(lastPP$xx)
XX <- lastPP$xx[node]
YY <- lastPP$yy[node]
for(i in 1:nrow(slice_df)){
focal <- slice_df[i,]
xx <- lastPP$xx[focal[2]] - focal[3]
yy <- lastPP$yy[focal[2]]
pp <- focal[-c(1:3)]
floating.pie.asp(xx, yy, pp, radius = 0.5, col = col)
}
}
# testing
library(corHMM)
library(parallel)
library(viridis)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
test <- ancRECON_slice(corhmm.obj, time_slice = c(10, 20, 30, 40), collapse = TRUE, ncores = 4)
plot_slice_recon(phy, test, col = viridis(5))
plot_slice_recon(phy, test, col = viridis(6))
library(corHMM)
?ancRECON_slice
library(viridis)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
corhmm.obj <- corHMM(phy = phy, data = data, rate.cat = 1)
test <- ancRECON_slice(corhmm.obj, time_slice = c(1, 10, 20, 30, 40, 49), collapse = TRUE, ncores = 4)
corHMM:::plot_slice_recon(phy, test, col = viridis(3))
test
head(test)
time_slice <- df[, "time_slice"]  # Extract the time_slice column
df <- ancRECON_slice(corhmm.obj, time_slice = c(1, 10, 20, 30, 40, 49), collapse = TRUE, ncores = 4)
time_slice <- df[, "time_slice"]  # Extract the time_slice column
probabilities <- df[, c("(1,R1)", "(2,R1)", "(3,R1)")]  # Extract the probability columns
df_long <- df %>%
pivot_longer(cols = c("(1,R1)", "(2,R1)", "(3,R1)"), names_to = "Probability", values_to = "Value")
library(dplyr)
df_long <- df %>%
pivot_longer(cols = c("(1,R1)", "(2,R1)", "(3,R1)"), names_to = "Probability", values_to = "Value")
library(tidyverse)
df_long <- df %>%
pivot_longer(cols = c("(1,R1)", "(2,R1)", "(3,R1)"), names_to = "Probability", values_to = "Value")
df
time_slice <- df[, "time_slice"]  # Extract the time_slice column
probabilities <- df[, c("(1,R1)", "(2,R1)", "(3,R1)")]  # Extract the probability columns
df_long <- df %>%
pivot_longer(cols = c("(1,R1)", "(2,R1)", "(3,R1)"), names_to = "Probability", values_to = "Value")
pivot_longer
df_long <- df %>%
pivot_longer(cols = c("(1,R1)", "(2,R1)", "(3,R1)"), names_to = "Probability", values_to = "Value")
df
df_long <- df[,-c(2,3)] %>%
pivot_longer(cols = c("(1,R1)", "(2,R1)", "(3,R1)"), names_to = "Probability", values_to = "Value")
df[,-c(2,3)]
df_long <- df %>%
pivot_longer(cols = c("(1,R1)", "(2,R1)", "(3,R1)"), names_to = "Probability", values_to = "Value")
df_long <- data.frame(
time_slice = rep(time_slice, each = ncol(probabilities)),
Probability = rep(colnames(probabilities), times = nrow(probabilities)),
Value = as.vector(probabilities)
)
ggplot(df_long, aes(x = time_slice, y = Value, color = Probability)) +
geom_line() +
labs(x = "Time Slice", y = "Probability") +
scale_color_manual(values = c("(1,R1)" = "red", "(2,R1)" = "blue", "(3,R1)" = "green")) +
theme_minimal()
df_long
df
?aggregate(df)
df
df <- as.data.frame(df)
df$time_slice
df[,-c(1:3)
df[,-c(1:3)]
df[,-c(1:3)]
aggregate(df[,-c(1:3)], by = list(df$time_slice), mean)
aggregate(df[,-c(1:3)], by = list(df$time_slice), mean)
df_summ <- aggregate(df[,-c(1:3)], by = list(df$time_slice), mean)
df_summ
df_summ <- aggregate(df[,-c(1:3)], by = list(df$time_slice), sum)
df_summ
install.packages("networkD3")  # Install the networkD3 package if not already installed
library(networkD3)
time_points <- df$Group.1
df_summ
time_points <- df_summ$Group.1
probabilities <- df_summ[, c("(1,R1)", "(2,R1)", "(3,R1)")]
time_points
probabilities
create_sankey_plot <- function(time_slice, probabilities) {
# Create a data frame for the Sankey plot
sankey_data <- data.frame(
from = rep("Group", each = nrow(probabilities)),
to = colnames(probabilities),
value = as.vector(probabilities)
)
# Create the Sankey plot
sankeyPlot(
Links = sankey_data,
Nodes = data.frame(name = unique(c(sankey_data$from, sankey_data$to))),
Source = "from",
Target = "to",
Value = "value",
NodeID = "name",
sinksRight = FALSE
)
}
for (i in 1:length(time_points)) {
plot_title <- paste("Time Point:", time_points[i])
plot <- create_sankey_plot(time_points[i], probabilities[i, ])
# Display the Sankey plot
cat(paste0("<h3>", plot_title, "</h3>"))
print(plot)
}
library(hisse)
simulated.result <- SimulateHisse(c(.3, .1), c(.1, 0),
matrix(c(NA, 0.2, .3, NA), nrow=2), max.taxa=35, x0=1)
par(mfcol=c(1,2))
plot(SimToPhylo(simulated.result$results, include.extinct=TRUE))
plot(SimToPhylo(simulated.result$results, include.extinct=FALSE))
simulated.result
library(OUwie)
library(phylolm)
load("~/Downloads/Rdata4Jeremy.RData")
species <- data_hind$species
loc3b_hind <- data_hind$Loc_mode_3bgroups
loc3c_hind <- data_hind$Loc_mode_3cgroups
### fbl ####
fbl_lsr <- (as.numeric(as.character(data_hind$fbl_lsr_hind)))
names(fbl_lsr) <- rownames(fbl_lsr)
#### forelimb dataframes for OUwie ####
fbl_lsr_loc3b <- data.frame(species, loc3b_hind, (fbl_lsr+10))
fbl_lsr_loc3c <- data.frame(species, loc3c_hind, (fbl_lsr+10))
#### test - loc3b OUM Model on first tree ####
fbl_lsr_OUM_loc3b_test <- OUwie(simmap_loc3b_5k_s250_hind[[1]], fbl_lsr_loc3b, model="OUM", simmap.tree=TRUE,root.station=FALSE, mserr = "none", algorithm = "three.point", diagn=T)
fbl_lsr_OUM_loc3b_test
#### test - loc3b OUM Model on first tree ####
fbl_lsr_OUM_loc3b_test <- OUwie(simmap_loc3b_5k_s250_hind[[1]], fbl_lsr_loc3b, model="OUM", simmap.tree=TRUE,root.station=FALSE, mserr = "none", algorithm = "three.point", diagn=F)
fbl_lsr_OUM_loc3b_test
fbl_lsr_loc3b
simmap_loc3b_5k_s250_hind[[1]]
plotSimmap(simmap_loc3b_5k_s250_hind[[1]])
dev.off()
debug(OUwie)
#### test - loc3b OUM Model on first tree ####
fbl_lsr_OUM_loc3b_test <- OUwie(simmap_loc3b_5k_s250_hind[[1]], fbl_lsr_loc3b, model="OUM", simmap.tree=TRUE,root.station=FALSE, mserr = "none", algorithm = "three.point", diagn=T)
fbl_lsr_loc3b
fbl_lsr_loc3b$loc3b_hind
factor(fbl_lsr_loc3b$loc3b_hind)
simmap_loc3b_5k_s250_hind
simmap_loc3b_5k_s250_hind[[1]]
#### test - loc3b OUM Model on first tree ####
fbl_lsr_OUM_loc3b_test <- OUwie(simmap_loc3b_5k_s250_hind[[1]], fbl_lsr_loc3b, model="OUM", simmap.tree=TRUE,root.station=FALSE, mserr = "none", algorithm = "three.point", diagn=T)
debug(dev)
nloptr(x0 = log(ip), eval_f = dev, lb = lower,
ub = upper, opts = opts, index.mat = index.mat,
edges = edges, mserr = mserr, trendy = trendy, get.root.theta = get.root.theta)
p
pars
expected.vals
phylolm::three.point.compute(transformed.tree$tree,
x, expected.vals, transformed.tree$diag)
transformed.tree$diag
transformed.tree$tree
transformPhy(phy, map, pars,
tip.paths)
phy
map
pars
tip.paths
phy
phy$edge.length
range(phy$edge.length)
is.ultrametric(phy)
debug(transformPhy)
transformPhy(phy, map, pars,
tip.paths)
RootAge
nTip
NodeAges
tmp.v
Dist_tipward
pars[, 2]
match(names(Map_i)[j]
, rownames(pars))
rownames(pars)
names(Map_i)
Map_i
names(Map_i)
names(Map_i)[j]
pars
rownames(pars)
pars
tot.states
as.numeric(tot.states)
tot.states
tot.states
tot.states
as.numeric(tot.states)
tot.states
pars
tot.states
tot.states
tot.states
tot.states
library(OUwie)
load("~/Downloads/Rdata4Jeremy.RData")
species <- data_hind$species
loc3b_hind <- data_hind$Loc_mode_3bgroups
loc3c_hind <- data_hind$Loc_mode_3cgroups
### fbl ####
fbl_lsr <- (as.numeric(as.character(data_hind$fbl_lsr_hind)))
names(fbl_lsr) <- rownames(fbl_lsr)
#### forelimb dataframes for OUwie ####
fbl_lsr_loc3b <- data.frame(species, loc3b_hind, (fbl_lsr+10))
fbl_lsr_loc3c <- data.frame(species, loc3c_hind, (fbl_lsr+10))
#### test - loc3b OUM Model on first tree ####
fbl_lsr_OUM_loc3b_test <- OUwie(simmap_loc3b_5k_s250_hind[[1]], fbl_lsr_loc3b, model="OUM", simmap.tree=TRUE,root.station=FALSE, mserr = "none", algorithm = "three.point", diagn=T)
fbl_lsr_OUM_loc3b_test
library(OUwie)
load("~/Downloads/Rdata4Jeremy.RData")
species <- data_hind$species
loc3b_hind <- data_hind$Loc_mode_3bgroups
loc3c_hind <- data_hind$Loc_mode_3cgroups
### fbl ####
fbl_lsr <- (as.numeric(as.character(data_hind$fbl_lsr_hind)))
names(fbl_lsr) <- rownames(fbl_lsr)
#### forelimb dataframes for OUwie ####
fbl_lsr_loc3b <- data.frame(species, loc3b_hind, (fbl_lsr+10))
fbl_lsr_loc3c <- data.frame(species, loc3c_hind, (fbl_lsr+10))
#### test - loc3b OUM Model on first tree ####
fbl_lsr_OUM_loc3b_test <- OUwie(simmap_loc3b_5k_s250_hind[[1]], fbl_lsr_loc3b, model="OUM", simmap.tree=TRUE,root.station=FALSE, mserr = "none", algorithm = "three.point", diagn=T)
fbl_lsr_OUM_loc3b_test
?OUwie
data(tworegime)
#Plot the tree and the internal nodes to highlight the selective regimes:
select.reg<-character(length(tree$node.label))
select.reg[tree$node.label == 1] <- "black"
select.reg[tree$node.label == 2] <- "red"
plot(tree)
nodelabels(pch=21, bg=select.reg)
## Not run:
#To see the first 5 lines of the data matrix to see what how to
#structure the data:
trait[1:5,]
#Now fit an OU model that allows different sigma^2:
OUwie(tree,trait,model=c("OUMV"))
#Fit an OU model based on a clade of interest:
OUwie(tree,trait,model=c("OUMV"), clade=c("t50", "t64"), algorithm="three.point")
fbl_lsr_OUM_loc3b_test
rm(list=ls())
setwd("~/2022_dentist/")
set.seed(1)
library(diversitree)
library(dentist)
###### ###### ###### ###### ######
# example 1
###### ###### ###### ###### ######
neglnL <- function(par) {
return(abs(10-par[1]-5*par[2]))
}
lnL <- function(par) {
return(-neglnL(par))
}
# samples <- mcmc(lik=lnL, x.init=c(5,1), nsteps=10000, w=5, prior=make.prior.exponential(10))
# save(samples, file="saves/samples-1.RData")
load("saves/samples-1.RData")
hist(samples$X1)
plot(X2 ~ X1, samples, pch=19, cex=.2, col="#00000055", asp=1)
plot(X2 ~ X1, samples)
col <- c("blue", "red")
# dented_results <- dent_walk(par=c(x=5,y=1), fn=neglnL, best_neglnL = neglnL(c(5,1)), sd=1, nsteps=2500, lower_bound = -Inf, upper_bound = Inf)
#save(dented_results, file="saves/dented_results-1.RData")
load("saves/dented_results-1.RData")
setwd("~/dentist-paper/")
set.seed(1)
library(diversitree)
library(dentist)
###### ###### ###### ###### ######
# example 1
###### ###### ###### ###### ######
neglnL <- function(par) {
return(abs(10-par[1]-5*par[2]))
}
lnL <- function(par) {
return(-neglnL(par))
}
# samples <- mcmc(lik=lnL, x.init=c(5,1), nsteps=10000, w=5, prior=make.prior.exponential(10))
# save(samples, file="saves/samples-1.RData")
load("saves/samples-1.RData")
hist(samples$X1)
plot(X2 ~ X1, samples, pch=19, cex=.2, col="#00000055", asp=1)
plot(X2 ~ X1, samples)
col <- c("blue", "red")
# dented_results <- dent_walk(par=c(x=5,y=1), fn=neglnL, best_neglnL = neglnL(c(5,1)), sd=1, nsteps=2500, lower_bound = -Inf, upper_bound = Inf)
#save(dented_results, file="saves/dented_results-1.RData")
load("saves/dented_results-1.RData")
# save a pdf of the plot
pdf("plots/algebraic-example-1.pdf", width=10, height=10)
plot(dented_results)
profiles.plot(samples[c("X1", "X2")], col.line=col, las=1,
xlab="Val 1", legend="topright")
density_values <- density(rexp(1e6, 10))
lines(density_values$x, density_values$y, lwd=2)
dev.off()
plot(dented_results)
profiles.plot(samples[c("X1", "X2")], col.line=col, las=1,
xlab="Val 1", legend="topright")
density_values <- density(rexp(1e6, 10))
lines(density_values$x, density_values$y, lwd=2)
dented_results
?dentist:::plot.dentist()
plot(dented_results)
plot(dented_results, cex = 2)
?plot
plot(dented_results, ylab = "y value")
